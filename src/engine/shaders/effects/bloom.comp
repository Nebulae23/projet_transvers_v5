#version 450 core

// Définir la taille du groupe de travail local (par exemple, 8x8)
layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

// Textures d'entrée et de sortie
// 'binding = 0' pour la texture source (les zones lumineuses extraites)
// 'binding = 1' pour la texture de destination (résultat du flou)
layout (rgba16f, binding = 0) uniform readonly image2D sourceTexture;
layout (rgba16f, binding = 1) uniform writeonly image2D resultTexture;

// Uniforms pour contrôler le flou
uniform bool horizontal; // Indique si c'est une passe horizontale ou verticale
uniform float weights[5] = float[] (0.227027, 0.1945946, 0.1216216, 0.054054, 0.016216); // Poids gaussiens précalculés (5 échantillons)

void main()
{
    // Obtenir les coordonnées globales du pixel traité par ce thread
    ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy);
    // Obtenir la taille de la texture pour les vérifications de limites
    ivec2 texSize = imageSize(sourceTexture);

    // Assurer que nous sommes dans les limites de la texture
    if (pixelCoords.x >= texSize.x || pixelCoords.y >= texSize.y) {
        return;
    }

    // Échantillonner le pixel central
    vec3 result = imageLoad(sourceTexture, pixelCoords).rgb * weights[0];

    // Échantillonner les voisins selon l'orientation (horizontale ou verticale)
    if (horizontal)
    {
        for (int i = 1; i < 5; ++i)
        {
            // Pixels à droite
            ivec2 rightCoords = pixelCoords + ivec2(i, 0);
            if (rightCoords.x < texSize.x) // Vérifier les limites
                result += imageLoad(sourceTexture, rightCoords).rgb * weights[i];

            // Pixels à gauche
            ivec2 leftCoords = pixelCoords - ivec2(i, 0);
            if (leftCoords.x >= 0) // Vérifier les limites
                result += imageLoad(sourceTexture, leftCoords).rgb * weights[i];
        }
    }
    else // Vertical
    {
        for (int i = 1; i < 5; ++i)
        {
            // Pixels en bas
            ivec2 downCoords = pixelCoords + ivec2(0, i);
            if (downCoords.y < texSize.y) // Vérifier les limites
                result += imageLoad(sourceTexture, downCoords).rgb * weights[i];

            // Pixels en haut
            ivec2 upCoords = pixelCoords - ivec2(0, i);
            if (upCoords.y >= 0) // Vérifier les limites
                result += imageLoad(sourceTexture, upCoords).rgb * weights[i];
        }
    }

    // Écrire le résultat flouté dans la texture de destination
    imageStore(resultTexture, pixelCoords, vec4(result, 1.0));
}