#version 450 core

// Taille du groupe de travail local (par exemple, 4x4x4 voxels)
layout (local_size_x = 4, local_size_y = 4, local_size_z = 4) in;

// Texture 3D pour stocker les données du brouillard (scattering et extinction)
// RGBA16F: RGB = In-Scattering, A = Extinction/Density
layout (rgba16f, binding = 0) uniform writeonly image3D fogVolumeTexture;

// Uniforms pour les paramètres du brouillard et de la scène
uniform vec3 volumeDimensions; // Taille de la grille 3D (nombre de voxels)
uniform vec3 volumeMinBounds;  // Coordonnées minimales de la grille dans l'espace monde
uniform vec3 volumeMaxBounds;  // Coordonnées maximales de la grille dans l'espace monde

uniform mat4 invViewProjMatrix; // Inverse de la matrice Vue * Projection
uniform vec3 cameraPos;         // Position de la caméra dans l'espace monde

// Paramètres du brouillard
uniform float fogDensity = 0.1;
uniform float scatteringCoeff = 0.05; // Coefficient de diffusion (in-scattering)
uniform float extinctionCoeff = 0.08; // Coefficient d'extinction (absorption + out-scattering)
uniform float anisotropy = 0.2;       // Facteur d'anisotropie (diffusion directionnelle, e.g., Henyey-Greenstein)

// Informations sur la lumière (simplifié : une seule lumière directionnelle)
uniform vec3 lightDirection = normalize(vec3(0.5, -1.0, 0.2));
uniform vec3 lightColor = vec3(1.0, 0.9, 0.7);
uniform float lightIntensity = 5.0;

// Optionnel : Shadow Map pour l'occultation par les ombres
// uniform sampler2DShadow shadowMap;
// uniform mat4 lightSpaceMatrix;

// Fonction de phase Henyey-Greenstein (simple modèle de diffusion directionnelle)
float phaseFunction(float cosTheta, float g) {
    float g2 = g * g;
    return (1.0 - g2) / (4.0 * 3.14159265 * pow(1.0 + g2 - 2.0 * g * cosTheta, 1.5));
}

// Fonction pour convertir les coordonnées du voxel en position monde
vec3 voxelCoordToWorldPos(ivec3 voxelCoord) {
    vec3 normalizedPos = (vec3(voxelCoord) + 0.5) / volumeDimensions; // Centre du voxel [0, 1]
    return mix(volumeMinBounds, volumeMaxBounds, normalizedPos);
}

void main()
{
    // Coordonnées globales du voxel traité par ce thread
    ivec3 voxelCoord = ivec3(gl_GlobalInvocationID.xyz);
    ivec3 volumeSize = ivec3(volumeDimensions);

    // Vérifier si le voxel est dans les limites de la grille
    if (any(greaterThanEqual(voxelCoord, volumeSize))) {
        return;
    }

    // Calculer la position du centre du voxel dans l'espace monde
    vec3 worldPos = voxelCoordToWorldPos(voxelCoord);

    // --- Calcul de l'In-Scattering (lumière diffusée vers la caméra) ---

    // Calculer la visibilité de la lumière (ombre) - Simplifié pour l'instant
    float shadow = 1.0;
    // // Exemple avec shadow map:
    // vec4 lightSpacePos = lightSpaceMatrix * vec4(worldPos, 1.0);
    // vec3 projCoords = lightSpacePos.xyz / lightSpacePos.w;
    // projCoords = projCoords * 0.5 + 0.5;
    // float currentDepth = projCoords.z;
    // if (projCoords.z < 1.0) { // Vérifier si dans le frustum de la lumière
    //     shadow = textureProj(shadowMap, vec4(projCoords.xy, currentDepth - bias, 1.0)); // bias à définir
    // }

    // Calculer la direction vers la lumière et vers la caméra
    vec3 L = -lightDirection; // Direction de la lumière
    vec3 V = normalize(cameraPos - worldPos); // Direction vers la caméra
    float cosTheta = dot(V, L); // Cosinus de l'angle entre V et L

    // Calculer la fonction de phase
    float phase = phaseFunction(cosTheta, anisotropy);

    // Calculer l'in-scattering
    vec3 inScattering = vec3(0.0);
    if (shadow > 0.0) { // Si le voxel n'est pas complètement dans l'ombre
        inScattering = lightColor * lightIntensity * phase * scatteringCoeff * fogDensity * shadow;
    }

    // --- Calcul de l'Extinction (lumière absorbée ou diffusée hors de vue) ---
    float extinction = extinctionCoeff * fogDensity;

    // Stocker les résultats dans la texture 3D
    // RGB = In-Scattering, A = Extinction
    imageStore(fogVolumeTexture, voxelCoord, vec4(inScattering, extinction));
}